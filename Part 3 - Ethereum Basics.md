## Accounts

- On the Blockchain, state is madeup of objects called "Accounts". Each account is a 20-byte address stored in a Patricia Merkle Tree.
- There are two types of accounts; Externally Owned Accounts, and Contract Accounts.
  - EOA's are controlled by people via private keys and are capable of:
    - maintaining a balance
    - sending transactions (transferring value/ initiating contract code)
    - keeps a nonce which tracks the number of transactions made by the account
  - CA's are similar to EOA's with the exception of being controlled directly by a person but rather a smart contract. CA's are unique in the sense that they can:
    - Call other contracts
    - Are initiated by external transactions
    - Can manipulate its storage
- A public address (EOA) is derived from the last 20 bytes of the public key controlling the account after the public key has been passed through Keccak-256 hash.
- Contract accounts are created either by EOA's or other CA's when a contract is deployed. The new contract address is generated by using the address of the parent account and the nonce of that account.

## Transactions

- Transactions are the mechanism in which state is modified in the blockchain. This can be accomplished through changing an ether account balance or by changing what is being stored in a contract.
- Transactions are always signed by the sender.
- Transactions can be sent from either EOA's or CA's and can include Ether or data.
- If the recipient of the data is a contract account the incoming data will be executed by the smart contract.
- If the recipient is not specified or the public address is 0x0 then the transaction creates a new contract. The input data will be executed and the output is stored as the contract to a new address generated by the original senders public address and nonce.
- Ethereum transactions include:

  - Recipient Address
  - Nonce
  - Cryptographic Variables V, R, and S
    - USed to verify senders signature is valid
  - Gas Limit
    - Max. number of computational steps the tx execution is allowed to take.
  - Gas Price
    - Fee the sender pays per computational step (higher gas price = faster tx execution times)
  - Value (optional)
    - Amount of Ether to send with tx (in Wei)
  - Data (optional)
    - Specifies contract instructions or deployment instructions

## Gas and Fees

- Executing operations on the Etheruem network is similar to a home or business that uses electricity available on a grid.
- Gas is the metering unit for computations executed on the Ethereum Virtual Machine. Each computation consumes gas because they consume time and energy to process.
- Different computations cost different amounts of gas.
- Fees help prevent spam in the network, or infinite loops.
- A transaction must provide enough gas to cover all the computations that will be executed on the EVM. Each computation consumes some of the gas specified in the transactions gas limit.
  - If there is any gas remaining at the end of the transaction execution it is returned to the sender.
  - If not enough gas was provided the execution is halted, the miner recieves the gas provided and the sender gets nothing.
- Before any computation is performed the EVM must know that the user is capable of paying for it. Therefore startGas or gas is disclosed with the initally.

## Ethereum Structure

- The Ethereum Virtual Machine (EVM) runs on every node in the network and handles all transactions being processed.
- The EVM is slow when compared to most VM's however it also coordinates between an entire distributed network of nodes that are both slow and fast, each of which processing every transaction.
- The EVM runs on bytecode, a low-level stack-based language that specifies how state transitions are applied to the networks state.
- Ethereum transctions contain bytecode that is interpreted by the EVM.

![EVM Bytecode](/images/evmBytecode.png)

- Contract accounrs keep contract bytecode in storage, when a transaction is recieved the EVM executes the contract bytecode, resulting in an update in state of the system.
  ![Smart Contract Bytecode](/images/smartContract_Bytecode.png)

- There are several high level programming languages that are used to create contracts. Any contract written in a high level programming language is compiled into Bytecode prior to execution.
  - The most popular language is Solidity.

## Uncled Blocks

- Uncled blocks result from Ethereums short block times and proof-of-work, they are valid blocks that are discovered but not included in the main chain.
- Blocks are discovered approximately every 15 seconds, these short blocktimes require a low difficulty which results in a high frequency of simultaneous block discoveries.
  - Network delays and internet latency provide some nodes with the advantage of receieving discovered block notifications before other miners, therefore they are able to get a head start on mining new blocks. This promotes centeralization to nodes located near mining pools.
- In ethereum discovering uncled blocks is rewarded, the motive is to incentivize decentralization away from mining pools.

## Resources

### Accounts

[How are ethereum addresses generated?](https://ethereum.stackexchange.com/questions/3542/how-are-ethereum-addresses-generated)

[Create Full Ethereum Wallet, Keypair and Address](https://kobl.one/blog/create-full-ethereum-keypair-and-address/)

### Ethereum Structure

[Ethereum Development tutorial -- Ethereum Docs](https://github.com/ethereum/wiki/wiki/Ethereum-Development-Tutorial)
